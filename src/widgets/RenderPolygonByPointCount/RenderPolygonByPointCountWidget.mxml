<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////
// 需要一个点图层和一个面图层，按照每个面元素中点的数量，配置面的symbol
// 所有颜色保存在配置文件中，根据点数量的最大值和最小值决定每个区(max-min)/colorCount
// 然后再根据颜色和区间动态生成ClassBreaksRenderer
// 如果设置了标注点图层，则在标注点的位置显示标注（名称，类型，数量）
///////////////////////////////////////////////////////////////////////////
-->
<TGISViewer:BaseWidget xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx" 
					   xmlns:TGISViewer="cn.seisys.TGISViewer.*" 
					   layout="absolute" 
					   widgetConfigLoaded="this_widgetConfigLoadedHandler(event)" 
					   creationComplete="this_creationCompleteHandler(event)">
	
	<fx:Script>
		<![CDATA[
			import com.esri.ags.FeatureSet;
			import com.esri.ags.Graphic;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.layers.GraphicsLayer;
			import com.esri.ags.renderers.ClassBreaksRenderer;
			import com.esri.ags.renderers.supportClasses.ClassBreakInfo;
			import com.esri.ags.symbols.SimpleFillSymbol;
			import com.esri.ags.symbols.SimpleLineSymbol;
			import com.esri.ags.symbols.TextSymbol;
			import com.esri.ags.tasks.GeometryService;
			import com.esri.ags.tasks.GeometryServiceSingleton;
			import com.esri.ags.tasks.QueryTask;
			import com.esri.ags.tasks.supportClasses.Query;
			import com.esri.ags.tasks.supportClasses.RelationParameters;
			
			import mx.collections.ArrayCollection;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.rpc.AsyncResponder;
			import mx.rpc.Fault;
			
			
			
			private var _pointQueryTask:QueryTask;
			private var _polygonQueryTask:QueryTask;
			private var _labelQueryTask:QueryTask;
			
			/**
			 * 点图层查询是否完毕
			 * 点和面图层都查询完毕再执行GeometryService.relation
			 * */
			private var _pointQueryTaskFinish:Boolean = false;
			/**
			 * 面图层查询是否完毕
			 * 点和面图层都查询完毕再执行GeometryService.relation
			 * */
			private var _polygonQueryTaskFinish:Boolean = false;
			
			/**
			 * 用于geometryService.relation的MapPoint数组（不是graphic，是graphic.geometry）
			 * */
			private var _pointGeometryArray:Array;
			/**
			 * 用于geometryService.relation的Polygon数组（不是graphic，是graphic.geometry）
			 * */
			private var _polygonGeometryArray:Array;
			/**
			 * 保存图层query结果
			 * */
			private var _polygonGraphicAC:ArrayCollection;
			
			private var _geometryService:GeometryService;
			private var _relationParam:RelationParameters;
			
			/**
			 * 渐变色
			 * */
			private var _gradientColorArray:Array;
			
			/**
			 * 显示不同颜色polygon的GraphicsLayer
			 * */
			private var _polygonLayer:GraphicsLayer;
			
			/**
			 * 标注点图层中的名称字段，和面图层中的名称字段对应
			 * */
			private var _labelPointLayerNameField:String
			/**
			 * 面图层中的名称字段，和标注点图层中的名称字段对应
			 * */
			private var _polygonLayerNameField:String;
			
			private var _labelPointGraphicAC:ArrayCollection;
			/**
			 * 显示文字标注的图层
			 * */
			private var _labelLayer:GraphicsLayer;
			
			protected function this_creationCompleteHandler(event:FlexEvent):void
			{
				_geometryService = new GeometryService( GeometryServiceSingleton.instance.url );
				_geometryService.token = GeometryServiceSingleton.instance.token;
				_geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;
				
				_relationParam = new RelationParameters();
				_relationParam.spatialRelationship = RelationParameters.SPATIAL_REL_WITHIN;
				
				_gradientColorArray = [];
				
				_polygonGraphicAC = new ArrayCollection();
				
				_labelPointGraphicAC = new ArrayCollection();
				
				_polygonLayer = new GraphicsLayer();
				_polygonLayer.id = "colorRendererPolygonLayer";
				map.addLayer( _polygonLayer );
				//面图层放在标线和标注下方
				map.reorderLayer( "colorRendererPolygonLayer", 1 );
				
				_labelLayer = new GraphicsLayer();
				map.addLayer( _labelLayer );
			}
			
			protected function this_widgetConfigLoadedHandler(event:Event):void
			{
				if ( configXML )
				{
					var pointLayerUrl:String = configXML.pointlayer.url;
					if ( pointLayerUrl )
					{
						pointLayerUrl = pointLayerUrl.replace( "{serverip}", configData.arcgisServerIP );
						_pointQueryTask = new QueryTask( pointLayerUrl );
						queryPoints();
					}
					
					var polygonLayerUrl:String = configXML.polygonlayer.url;
					if ( polygonLayerUrl )
					{
						polygonLayerUrl = polygonLayerUrl.replace( "{serverip}", configData.arcgisServerIP );
						_polygonQueryTask = new QueryTask( polygonLayerUrl );
						queryPolygons();
					}
					
					
					var labelLayerUrl:String = configXML.labellayer.url;
					if ( labelLayerUrl )
					{
						_labelPointLayerNameField = configXML.labellayer.pointnamefield;
						_polygonLayerNameField = configXML.labellayer.polygonnamefield;
						
						labelLayerUrl = labelLayerUrl.replace( "{serverip}", configData.arcgisServerIP );
						_labelQueryTask = new QueryTask( labelLayerUrl );
						queryLabels();
					}
					//渐变色
					/*var gradientColor1:int = configXML.polygonlayer.gradient.color1;
					var gradientColor2:int = configXML.polygonlayer.gradient.color2;
					var gradientCount:int = configXML.polygonlayer.gradient.count;
					generateGradientColorArray( gradientColor1, gradientColor2, gradientCount );*/
					var gradientColorString:String = configXML.polygonlayer.gradientcolor;
					_gradientColorArray = gradientColorString.split( "," );
				}
			}
			
			/*private function generateGradientColorArray( color1:int, color2:int, count:int ):void
			{
				var color1R:int = color1 >> 16;
				var color1G:int = ( color1 >> 8 ) & 0xff;
				var color1B:int = color1 & 0xff;
				
				var color2R:int = color2 >> 16;
				var color2G:int = ( color2 >> 8 ) & 0xff;
				var color2B:int = color2 & 0xff;
				
				for ( var i:int = 0; i <= count; i++ )
				{
					var r:int = Number.min( color1R + i * ( color2R - color1R ) / count, 255 );
					var g:int = Number.min( color1G + i * ( color2G - color1G ) / count, 255 );
					var b:int = Number.min( color1B + i * ( color2B - color1B ) / count, 255 );
					var color:int = r << 16 | g << 8 | b;
					_gradientColorArray.push( color ); 
				}
			}*/
			
			private function queryPoints():void
			{
				CursorManager.setBusyCursor();
				
				var query:Query = new Query();
				query.returnGeometry = true;
				query.where = "1=1";
				query.outSpatialReference = map.spatialReference;
				_pointQueryTask.execute( query, new AsyncResponder( onResult, onFault ) );
				
				function onResult( featureSet:FeatureSet, token:Object = null ):void
				{
					_pointGeometryArray = [];
					for each ( var graphic:Graphic in featureSet.features )
					{
						graphic.geometry.spatialReference = map.spatialReference;
						_pointGeometryArray.push( graphic.geometry );
					}
					_pointQueryTaskFinish = true;
					if ( _pointQueryTaskFinish && _polygonQueryTaskFinish )
					{
						executeRelation();
					}
				}
			}
			
			private function queryPolygons():void
			{
				var query:Query = new Query();
				query.returnGeometry = true;
				query.where = "1=1";
				query.outSpatialReference = map.spatialReference;
				_polygonQueryTask.execute( query, new AsyncResponder( onResult, onFault ) );
				
				function onResult( featureSet:FeatureSet, token:Object = null ):void
				{
					_polygonGeometryArray = [];
					_polygonGraphicAC.removeAll();
					for each ( var graphic:Graphic in featureSet.features )
					{
						graphic.geometry.spatialReference = map.spatialReference;
						_polygonGeometryArray.push( graphic.geometry );
						
						graphic.attributes.count = 0;
						_polygonGraphicAC.addItem( graphic );
					}
					_polygonQueryTaskFinish = true;
					if ( _pointQueryTaskFinish && _polygonQueryTaskFinish )
					{
						executeRelation();
					}
				}
			}
			
			private function executeRelation():void
			{
				_relationParam.geometries1 = _pointGeometryArray;
				_relationParam.geometries2 = _polygonGeometryArray;
				_geometryService.relation( _relationParam, new AsyncResponder( onResult, onFault ) );
				
				function onResult( item:Object, token:Object = null ):void
				{
					var result:Array = item as Array;
					for each (var resultObj:Object in result)
					{
						var polygonIndex:int = resultObj.geometry2Index;
						var polygonGraphic:Graphic = _polygonGraphicAC.getItemAt( polygonIndex ) as Graphic;
						polygonGraphic.attributes.count++;
					}
					
					_polygonLayer.graphicProvider = _polygonGraphicAC;
					_polygonLayer.renderer = generateClassBreakRenderer();
					
					for each ( var graphic:Graphic in _polygonGraphicAC )
					{
						var centerPt:MapPoint = graphic.geometry.extent.center;
						var textSymbol:TextSymbol = new TextSymbol( graphic.attributes["名称"] + ":" + graphic.attributes["count"] );
						_labelLayer.add( new Graphic( centerPt, textSymbol ) );
					}
					
					generateLabels();
					
					CursorManager.removeBusyCursor();
				}
			}
			
			private function onFault( fault:Fault, token:Object = null ):void
			{
				CursorManager.removeBusyCursor();
				
				var strInfo: String = "Error: ";
				strInfo += "Fault Code: " + fault.faultCode + "\n";
				strInfo += "Fault Info: " + fault.faultString + "\n";
				strInfo += "Fault Detail: " + fault.faultDetail;
				showError( strInfo );
			}
			
			private function generateClassBreakRenderer():ClassBreaksRenderer
			{
				//得到数量的最大值和最小值
				var maxValue:Number = Number.MIN_VALUE;
				var minValue:Number = Number.MAX_VALUE;
				for each ( var graphic:Graphic in _polygonGraphicAC )
				{
					var count:int = graphic.attributes.count;
					maxValue = Number.max( maxValue, count );
					minValue = Number.min( minValue, count );
				}
				
				var classCount:int = _gradientColorArray.length;
				var classMinValue:Number = int( minValue );
				var classBreakInfoArray:Array = [];
				
				for ( var i:int = 1; i <= classCount; i++ )
				{
					var classMaxValue:Number = int( minValue + ( maxValue - minValue ) * i / classCount );
					var classColor:Number = _gradientColorArray[i-1];
					var symbol:SimpleFillSymbol = new SimpleFillSymbol( "solid", classColor, 0.8, 
						new SimpleLineSymbol( "solid", classColor, 1, 2 ) );
					var classBreakInfo:ClassBreakInfo = new ClassBreakInfo( symbol, 
						classMinValue, classMaxValue );
					classBreakInfoArray.push( classBreakInfo );
					
					classMinValue = classMaxValue + 0.00001;
				}
				
				var classBreaksRenderer:ClassBreaksRenderer = new ClassBreaksRenderer( 
					"count", null, classBreakInfoArray );
				return classBreaksRenderer;
			}
			
			private function queryLabels():void
			{
				var query:Query = new Query();
				query.returnGeometry = true;
				query.where = "1=1";
				query.outSpatialReference = map.spatialReference;
				_labelQueryTask.execute( query, new AsyncResponder( onResult, onFault ) );
				
				function onResult( featureSet:FeatureSet, token:Object = null ):void
				{
					for each ( var labelGraphic:Graphic in featureSet.features )
					{
						_labelPointGraphicAC.addItem( labelGraphic );
						/*var labelPointLayerName:String = labelGraphic.attributes[ _labelPointLayerNameField ];
						for each ( var polygonGraphic:Graphic in _polygonGraphicAC )
						{
							var polygonLayerName:String = polygonGraphic.attributes[ _polygonLayerNameField ];
							if ( labelPointLayerName == polygonLayerName )
							{
								trace( polygonLayerName, polygonGraphic.attributes.count );
								break;
							}
						}*/
					}
				}
			}
			
			private function generateLabels():void
			{
				for each ( var labelGraphic:Graphic in _labelPointGraphicAC )
				{
					var labelPointLayerName:String = labelGraphic.attributes[ _labelPointLayerNameField ];
					for each ( var polygonGraphic:Graphic in _polygonGraphicAC )
					{
						var polygonLayerName:String = polygonGraphic.attributes[ _polygonLayerNameField ];
						if ( labelPointLayerName == polygonLayerName )
						{
							break;
						}
					}
				}
			}
		]]>
	</fx:Script>
	
	
	
</TGISViewer:BaseWidget>
